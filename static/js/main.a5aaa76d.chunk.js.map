{"version":3,"sources":["styledComponents/blog-post-sc.js","components/blogPost.js","data/blogData.js","components/blog.js","App.js","serviceWorker.js","index.js"],"names":["BlogWrapper","styled","div","_templateObject","Title","button","_templateObject2","Content","_templateObject3","BlogPost","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","handleClick","state","showContent","setState","_this2","react_default","a","createElement","onClick","title","style","display","content","Component","data","Blog","makeBlogPosts","map","post","blogPost","App","blog","Boolean","window","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"ixBAEO,IAAMA,EAAcC,IAAOC,IAAVC,KAKXC,EAAQH,IAAOI,OAAVC,KAgBLC,EAAUN,IAAOC,IAAVM,KCkBLC,cArCd,SAAAA,EAAYC,GAAO,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAL,IAClBE,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAH,GAAAQ,KAAAH,KAAMJ,KAOPQ,YAAc,YACkB,IAA3BP,EAAKQ,MAAMC,YACdT,EAAKU,SAAS,CACbD,aAAa,IAGdT,EAAKU,SAAS,CACbD,aAAa,KAZfT,EAAKQ,MAAQ,CACZC,aAAa,GAJIT,wEAqBV,IAAAW,EAAAR,KACR,OACCS,EAAAC,EAAAC,cAAA,WACCF,EAAAC,EAAAC,cAACzB,EAAD,KACCuB,EAAAC,EAAAC,cAACrB,EAAD,CAAOsB,QAAS,kBAAMJ,EAAKJ,gBACzBJ,KAAKJ,MAAMiB,OAEbJ,EAAAC,EAAAC,cAAClB,EAAD,CAASqB,MAAO,CAACC,QAAQf,KAAKK,MAAMC,YAAc,QAAU,SAC1DN,KAAKJ,MAAMoB,kBA9BKC,aCFVC,EAAO,CAClB,CACEL,MAAO,mBACPG,QAAO,m+CAeT,CACEH,MAAO,oBACPG,QAAO,+sCCCIG,6MAhBbC,cAAgB,WAId,OAHkBF,EAAKG,IAAI,SAAAC,GACzB,OAAOb,EAAAC,EAAAC,cAACY,EAAD,CAAUV,MAAOS,EAAKT,MAAOG,QAASM,EAAKN,qFAMtD,OACCP,EAAAC,EAAAC,cAAA,WACEX,KAAKoB,wBAZSH,aCSJO,mLARX,OACEf,EAAAC,EAAAC,cAAA,WACEF,EAAAC,EAAAC,cAACc,EAAD,cAJUR,aCSES,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAOvB,EAAAC,EAAAC,cAACsB,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.a5aaa76d.chunk.js","sourcesContent":["import styled from 'styled-components';\r\n\r\nexport const BlogWrapper = styled.div`\r\n  text-align: center\r\n  margin: 5px;\r\n`;\r\n\r\nexport const Title = styled.button`\r\n  height: 35px;\r\n  width: 95%\r\n  border-radius: 4px;\r\n  border: 1px solid grey;\r\n  box-shadow: none;\r\n\r\n  &:hover {\r\n\t\tbackground: #4ddbff;\r\n\t}\r\n\r\n\t&:focus {\r\n\t\toutline: none;\r\n\t}\r\n`;\r\n\r\nexport const Content = styled.div`\r\n  text-align: left\r\n  margin: auto\r\n  width: 95%\r\n  border-radius: 4px;\r\n  border: 1px solid grey;\r\n`;","import React, { Component } from 'react';\r\nimport { BlogWrapper, Title, Content } from '../styledComponents/blog-post-sc';\r\n\r\nclass BlogPost extends Component {\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\r\n\t\tthis.state = {\r\n\t\t\tshowContent: false,\r\n\t\t}\r\n\t}\r\n\r\n\thandleClick = () => {\r\n\t\tif (this.state.showContent === true) {\r\n\t\t\tthis.setState({\r\n\t\t\t\tshowContent: false\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\tthis.setState({\r\n\t\t\t\tshowContent: true\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t}\r\n\r\n\trender() {\r\n\t\treturn (\r\n\t\t\t<div>\r\n\t\t\t\t<BlogWrapper>\r\n\t\t\t\t\t<Title onClick={() => this.handleClick()}>\r\n\t\t\t\t\t\t{this.props.title}\r\n\t\t\t\t\t</Title>\r\n\t\t\t\t\t<Content style={{display:this.state.showContent ? \"block\" : \"none\"}}>\r\n\t\t\t\t\t\t{this.props.content}\r\n\t\t\t\t\t</Content>\r\n\t\t\t\t</BlogWrapper>\r\n\t\t\t</div>\r\n\t\t)\r\n\t}\r\n}\r\n\r\nexport default BlogPost;\r\n","\r\nexport const data = [\r\n  {\r\n    title: \"Week #1 1/7/2019\",\r\n    content: `My week started with an update meeting with our client. We talked about what was needed to finish the application we \r\n    have been working on. I was assigned the task of finishing the ingestion script to populate the database and also to get the \r\n    database deployed on our server. While the front end is working with this new setup I would also need to help correct any problems.\r\n    \r\n    To build the ingestion script, I integrated a command into our project using PHP. The spreadsheet has been created using excel, so\r\n    I needed to create a tool that would read in not just cells from the worksheet, but also be able to switch between multiple worksheets\r\n    to gather data. To do this, I used a 3rd party library called phpspreadsheet. This allowed me to create a working script to use my entity\r\n    functions and populate a database.\r\n    \r\n    The initial push to move our database and API to a server went fairly smooth. We use npm and composer to track dependencies, so setup was\r\n    mostly just running install commands and then moving files to the server through WinSCP. However, to run the ingestion script, we needed to\r\n    install phpspreadsheet, which is a little more tricky. The library requires a 64 bit installation of PHP but what natively is available through\r\n    xammp is 32 bit. I solved this problem by installing a 64 version in addition to xampp and changing my windows environment variables. This allows\r\n    me to install the library then move it to the server.`\r\n  },\r\n  {\r\n    title: \"Week #2 1/14/2019\",\r\n    content: `We were given an important requirement to complete this week - build a unit conversion tool to add to the application. The conversion\r\n    tool would need to store coefficients and calculate conversion rates before returning a fully converted value. I started my week by building an\r\n    entity and controller for the backend to get and retrieve the information needed to accomplish this, while also responding to any problems we\r\n    had resulting from our move to a server last week.\r\n    \r\n    One thing we encountered on the server is that file permissions matter quite a lot. POST requests were being treated as GETS and it took a while\r\n    before a developer realized what the problem was. File permissions needed to be changed to give xammp the power to change things on the server.\r\n    \r\n    By midweek I had built the back-end logic to complete our unit conversion tool. I gave these changes to the front-end developers who worked to\r\n    create a demo-able example. When I returned on Friday, they had built a fully working tool with my API. We now needed to deploy everything to\r\n    the server. I worked to copy everything once again, and we spent the rest of the day double checking that everything was working.`\r\n  }\r\n]","import React, { Component } from 'react';\r\nimport BlogPost from './blogPost'\r\nimport { data } from '../data/blogData';\r\n\r\nclass Blog extends Component {\r\n\r\n  makeBlogPosts = () => {\r\n    const blogPosts = data.map(post => {\r\n      return <BlogPost title={post.title} content={post.content} />\r\n    })\r\n    return blogPosts;\r\n  }\r\n  \r\n  render() {\r\n\t\treturn (\r\n\t\t\t<div>\r\n\t\t\t\t{this.makeBlogPosts()}\r\n\t\t\t</div>\r\n\t\t)\r\n\t}\r\n}\r\n\r\nexport default Blog;","import React, { Component } from 'react';\r\nimport Blog from './components/blog';\r\n\r\nclass App extends Component {\r\n  render() {\r\n    return (\r\n      <div>\r\n        <Blog />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read http://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: http://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}